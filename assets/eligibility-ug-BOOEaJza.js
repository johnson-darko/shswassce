import{c as Y,n as j,m as N}from"./index-B8XQxo_D.js";function L(R,_,w){const y=[],v=Y(R);v.length>0&&v[0].aggregate;for(const r of _){const f=w.filter(i=>i.programId===r.id);if(f.length===0)continue;let g=null;for(const i of f){let a="not_eligible",h="",S=[],m=[],P=[],I,$,b=!1,l=null,c=null;if(i.requirementComplexity==="advanced"&&i.admissionTracks)continue;for(const s of v){let k=!0,x=[];({...R});for(const e of s.coreSubjects)(e.subject??"").toLowerCase().replace(/\s+/g,""),e.grade;k=!0,x=[];let u=!0,n=[];const d=new Set;let A=0,D=0;if(i.electiveSubjects&&i.electiveSubjects.length>0)for(const e of i.electiveSubjects){let p=!1;if(e.type==="single"){for(let o=0;o<s.electiveSubjects.length;o++){if(d.has(o))continue;const t=s.electiveSubjects[o];if(j(t.subject??"")===j(e.subject??"")&&N(t.grade??"",e.min_grade??"")){p=!0,n.push(`${t.subject}: ✓ ${t.grade}`),d.add(o),A++;break}}p||(u=!1,n.push(`${e.subject}: Need ${e.min_grade}`))}else if(e.type==="any"){let o=[];for(let t=0;t<s.electiveSubjects.length;t++){if(d.has(t))continue;const E=s.electiveSubjects[t];e.subjects.some(T=>j(E.subject??"")===j(T??""))&&N(E.grade??"",e.min_grade??"")&&o.push({idx:t,e:E})}if(o.length>=e.count)for(let t=0;t<e.count;t++)n.push(`${o[t].e.subject}: ✓ ${o[t].e.grade}`),d.add(o[t].idx),D++;else o.forEach(t=>{n.push(`${t.e.subject}: ✓ ${t.e.grade}`),d.add(t.idx)}),u=!1,n.push(`Any ${e.count} from: Need at least ${e.count} subjects with ${e.min_grade} or better`)}}const O=i.electiveSubjects.filter(e=>e.type==="single").length,B=i.electiveSubjects.filter(e=>e.type==="any").reduce((e,p)=>e+(p.count||0),0);u=u&&A===O&&D===B;let M=!i.aggregatePoints||s.aggregate<=i.aggregatePoints;if(k&&u&&M){l={combo:s,coreDetails:x,electivesDetails:n};break}else k&&u&&s.aggregate<=(i.aggregatePoints||999)+3&&(c={combo:s,coreDetails:x,electivesDetails:n})}l?(a="eligible",h="You meet all CORE requirements for this program!",S=[...l.coreDetails,...l.electivesDetails,`Aggregate: ✓ ${l.combo.aggregate}/${i.aggregatePoints}`],$=l.combo.combination,b=l.combo.isBest):c?(a="borderline",h="You're close to meeting the requirements",S=[...c.coreDetails,...c.electivesDetails,`Aggregate: ${c.combo.aggregate}/${i.aggregatePoints} (close)`],$=c.combo.combination,b=c.combo.isBest,m.push("Consider retaking subjects with borderline grades"),m.push("Apply anyway as requirements may be flexible")):(a="not_eligible",h="You do not meet the current requirements",m.push("Consider retaking key subjects to improve grades"),m.push("Look for foundation or bridging programs"));let q=30;a==="eligible"?q=b?100:90:a==="borderline"&&(q=b?70:60);const C={programId:r.id,programName:r.name,universityName:r.universityName,status:a,message:h,details:S,recommendations:m,matchScore:q,careerOutcomes:r.careerOutcomes,averageSalary:r.averageSalary,employmentRate:r.employmentRate,admissionTracks:P,bestTrackMatch:I,requirementComplexity:i.requirementComplexity,usedCombination:$,combinationFromBest:b,matchedRequirementId:i.id};if(a==="eligible"){g=C;break}(!g||(C.matchScore??0)>(g.matchScore??0))&&(g=C)}g&&y.push(g)}return y.sort((r,f)=>(f.matchScore||0)-(r.matchScore||0)),y}export{L as checkEligibilityUG};
